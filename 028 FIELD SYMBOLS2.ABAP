* Declara√ß√£o dos Field-Symbols
*-----------------------------------
FIELD-SYMBOLS: <fs_teste> TYPE ANY.

* Vari√°vel Qualquer
*-----------------------------------
DATA: v_matnr TYPE mara-matnr.

* Cria a refer√™ncia da √°rea de mem√≥ria no Field-Symbol. Note que
* √© necess√°rio colocar o nome da vari√°vel entre ( ), al√©m de o nome
* estar em letras ma√≠usculas.
ASSIGN ('V_MATNR') TO <fs_teste>.

IF  IS ASSIGNED.
 <fs_teste>  = 'MATERIALZUMBI'.
ENDIF.

WRITE v_matnr.

* A vantagem principal √© que voc√™ pode usar um mesmo field-symbol para alterar vari√°veis diferentes com a mesma linha de c√≥digo. Como no exemplo abaixo:
* Sempre que voc√™ for atribuir valores a um Field-Symbol verifique antes se o mesmo foi realmente referenciado, atrav√©s da consist√™ncia IS ASSIGNED. 
* Se voc√™ tentar usar um Field Symbols que n√£o foi corretamente referenciado, o programa ir√° gerar um DUMP! Voc√™ tamb√©m pode desfazer a refer√™ncia atrav√©s do comando UNASSIGN <fs>.
* Mas qual a vantagem disso tudo? Elementar meu caro leitor: usar o mesmo field-symbol para alterar valores de campos diferentes! üòÄ

REPORT zombie_assign.

* Declara√ß√£o dos Field-Symbols
*-----------------------------------
FIELD-SYMBOLS: <fs_teste> TYPE ANY.

* Note que cada vari√°vel √© de um tipo diferente!
*-----------------------------------
DATA: v_matnr TYPE mara-matnr,
      v_mtart TYPE mara-mtart,
      v_labst TYPE mard-labst.

* Cria a refer√™ncia da √°rea de mem√≥ria no Field-Symbol. Note que
* √© necess√°rio colocar o nome da vari√°vel entre ( ), al√©m de o nome
* estar em letras ma√≠usculas.
ASSIGN ('V_MATNR') TO <fs_teste>.

IF <fs_teste> IS ASSIGNED.
  <fs_teste> = 'MATERIALZUMBI'.
ENDIF.

WRITE <fs_teste>.

ASSIGN ('V_MTART') TO <fs_teste>.

IF <fs_teste> IS ASSIGNED.
  <fs_teste> = 'FERT'.
ENDIF.

WRITE <fs_teste>.

ASSIGN ('V_LABST') TO <fs_teste>.

IF <fs_teste> IS ASSIGNED.
  <fs_teste> = '1234'.
ENDIF.

WRITE <fs_teste>.

* O ASSIGN ainda tem mais coisas que podem ajud√°-lo em diversos momentos. Vamos l√°:
* ASSIGN COMPONENT OF STRUCTURE: Ele permite que voc√™ associe num Field-Symbol um campo qualquer de uma estrutura. E voc√™ nem precisa saber o nome exato do campo, s√≥ a posi√ß√£o dele na sequ√™ncia de declara√ß√£o da estrutura. vejamos:

REPORT zombie_assign.

* Declara√ß√£o dos Field-Symbols
*-----------------------------------
FIELD-SYMBOLS: <fs_wa> TYPE ANY.

* Work Area
*-----------------------------------
DATA: wa_mara TYPE mara.

* Assign de estrutura com o nome do campo da estrutura
ASSIGN COMPONENT 'MATNR' OF STRUCTURE wa_mara
                                   TO <fs_wa>.

IF <fs_wa> IS ASSIGNED.
  <fs_wa> = 'MATERIALZUMBI'.
ENDIF.

WRITE wa_mara-matnr.

* O campo 10 √© o campo MTART
ASSIGN COMPONENT 10 OF STRUCTURE wa_mara
                              TO <fs_wa>.

IF <fs_wa> IS ASSIGNED.
  <fs_wa> = 'FERT'.
ENDIF.

WRITE <fs_wa>.

* ASSIGN CASTING: Ele faz a mesma refer√™ncia dos outros, mas o field-symbol mostra o valor do tipo que voc√™ usou no casting. Ou seja, voc√™ pode associar uma vari√°vel char √† um field-symbol que ir√° mostrar o seu valor em hexadecimal.
* Isso √© √∫til para achar e manipular caracteres especiais em strings, como quebras de linha e tabs indesejados (aqueles que aparecem como # no debug).

REPORT zombie_assign.

* Declara√ß√£o dos Field-Symbols
*-----------------------------------
FIELD-SYMBOLS: <fs_x> TYPE ANY.

* Vari√°vel CHAR
*-----------------------------------
DATA: v_char TYPE char1.

* Referenciando o valor de V_CHAR trocando o tipo
ASSIGN ('V_CHAR') TO <fs_x> CASTING TYPE x.

* Se movermos AB para V_CHAR..
v_char = 'A'.

*... o WRITE do Field-Symbol escrever√° 41, que √© o c√≥digo em hexa do
* A  maiusculo :)
WRITE <fs_x>.
* ‚Äì ASSIGN de vari√°veis de outros programas: Voc√™ pode associar a mem√≥ria n√£o s√≥ do seu programa, mas de qualquer outro programa carregado na mem√≥ria da execu√ß√£o. Isso √© muito usado em EXITs, BADIs e Enhancement Points, para a leitura de dados que nem sempre est√£o dispon√≠veis na interface do FORM, Fun√ß√£o ou m√©todo:

* Um exemplo simples de cada capturar valores de outros programas carregados na mem√≥ria.
* Neste caso, estou capturando o valor de uma tabela que est√° declarada no
* programa SAPMV45A e associando a refer√™ncia no field-symbol.
ASSIGN ('(SAPMV45A)XVBAP') TO <fs_tabela>.

* Note que voc√™ pode usar as dicas do t√≥pico do Novo Debugger
* para navegar entre a pilha de programas carregados e verificar
*as vari√°veis que est√£o na mem√≥ria.
* - LOOP AsSIGNING / READ ASSIGNING: Voc√™ pode ainda associar uma estrutura durante um loop ou um read, economizando uma work area e alterando os valores direto na tabela. Eu uso muito isso para alterar valores na tabela em que estou dando um Loop:

REPORT zombie_assign.

* Nesta declara√ß√£o √© necess√°rio definir o tipo exato da Work Area para
* o Field-Symbol, caso contr√°rio o comando <fs_mara>-matnr n√£o ir√°
* ativar...
FIELD-SYMBOLS: <fs_mara> TYPE mara.

* Tabela
DATA: t_mara TYPE TABLE OF mara.

* Linha vazia, s√≥ para mostrar o Loop
APPEND INITIAL LINE TO t_mara.

LOOP AT t_mara ASSIGNING <fs_mara>.
* Associando o valor direto na linha
  <fs_mara>-matnr = 'MATERIALZUMBI'.
ENDLOOP.

* Analise a tabela. Sem MODIFY nem nada, os valores da linha foram
* alterados :) Voc√™ pode usar isto com o o READ TABLE tamb√©m!
BREAK-POINT.
